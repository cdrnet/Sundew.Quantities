using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using Microsoft.CodeAnalysis;

namespace Sundew.Quantities.Generator
{
    public class QuantityGenerator
    {
        public static GeneratorString Generate(string classFileName, ICodeGeneratorSettings codeGeneratorSettings, Project project, QuantityDefinition quantityDefinition)
        {
            return
$@"
// --------------------------------------------------------------------------------------------------------------------
// <copyright file=""{classFileName}"" company=""Hukano"">
// Copyright (c) Hukano. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
// </copyright>
// --------------------------------------------------------------------------------------------------------------------

// <auto-generated />
namespace {GetNamespace(project, codeGeneratorSettings.TargetNamespace)}
{{
{GetUsings(codeGeneratorSettings.UseGlobalUsings | quantityDefinition.UseGlobalUsings, 4, codeGeneratorSettings.Usings, quantityDefinition.Usings)}

    [GeneratedCode(""Sundew.Quantities.Generator"", ""1.0.0.0"")]
    public partial struct {quantityDefinition.Name} : IQuantity<{quantityDefinition.Name}, {quantityDefinition.UnitSelector}>
    {{
        private readonly double value;

{GetConstructors(quantityDefinition)}

        double IQuantity.Value => this.value;

        public IUnit Unit {{ get; }}

{GetStandardOperations(quantityDefinition)}

{GetConversionOperations(quantityDefinition)}

{GetEqualityOperations(quantityDefinition)}

{GetToStringOperations(quantityDefinition)}

        public {quantityDefinition.Name} CreateQuantity(double value, IUnit unit)
        {{
            return new {quantityDefinition.Name}(value, unit);
        }}

        IQuantity IDeferredQuantity.GetResult()
        {{
            return this;
        }}

        {quantityDefinition.UnitSelector} IQuantity<{quantityDefinition.Name}, {quantityDefinition.UnitSelector}>.CreateUnitSelector()
        {{
            return new {quantityDefinition.UnitSelector}();
        }}
    }}
}}
";
        }

        private static GeneratorString GetUsings(bool useGlobalUsings, int indent, params IEnumerable<string>[] usings)
        {
            var stringBuilder = new StringBuilder();
            var flattenedUsings = usings.Where(x => x != null).SelectMany(x => x);
            var allUsings = flattenedUsings.Distinct().OrderBy(x => x);
            var global = string.Empty;
            if (useGlobalUsings)
            {
                global = "global::";
            }

            foreach (var @using in allUsings)
            {
                stringBuilder.AppendLine($"{new string(' ', indent)}using {global}{@using};");
            }

            if (stringBuilder.Length < 3)
            {
                return string.Empty;
            }

            return stringBuilder.ToString(0, stringBuilder.Length - 2);
        }

        private static GeneratorString GetConstructors(QuantityDefinition quantityDefinition)
        {
            return new GeneratorString(8, $@"
public {quantityDefinition.Name}(double value, SelectUnit<{quantityDefinition.UnitSelector}> unitSelector)
    : this(value,  UnitBuilder.BuildUnit(unitSelector(new {quantityDefinition.UnitSelector}())))
{{
}}

public {quantityDefinition.Name}(IQuantity quantity)
    : this(quantity.Value, quantity.Unit)
{{
}}

public {quantityDefinition.Name}(double value)
    : this(value, units => units.BaseUnit)
{{
}}

public {quantityDefinition.Name}(double value, IUnit unit)
{{
    this.value = value;
    this.Unit = unit;
}}
");
        }

        private static GeneratorString GetStandardOperations(QuantityDefinition quantityDefinition)
        {
            return new GeneratorString(8, $@"
public static {quantityDefinition.Name} operator +({quantityDefinition.Name} quantity)
{{
    return quantity;
}}

public static {quantityDefinition.Name} operator -({quantityDefinition.Name} quantity)
{{
    return new {quantityDefinition.Name}(-quantity.value, quantity.Unit);
}}

public static {quantityDefinition.Name} operator ++({quantityDefinition.Name} quantity)
{{
    return new {quantityDefinition.Name}(quantity.value + 1, quantity.Unit);
}}

public static {quantityDefinition.Name} operator --({quantityDefinition.Name} quantity)
{{
    return new {quantityDefinition.Name}(quantity.value - 1, quantity.Unit);
}}

public static {quantityDefinition.Name} operator +({quantityDefinition.Name} lhs, double rhs)
{{
    return new {quantityDefinition.Name}(lhs.value + rhs, lhs.Unit);
}}

public static {quantityDefinition.Name} operator -({quantityDefinition.Name} lhs, double rhs)
{{
    return new {quantityDefinition.Name}(lhs.value - rhs, lhs.Unit);
}}

public static {quantityDefinition.Name} operator *({quantityDefinition.Name} lhs, double rhs)
{{
    return new {quantityDefinition.Name}(lhs.value * rhs, lhs.Unit);
}}

public static {quantityDefinition.Name} operator /({quantityDefinition.Name} lhs, double rhs)
{{
    return new {quantityDefinition.Name}(lhs.value / rhs, lhs.Unit);
}}

public static {quantityDefinition.Name} operator +({quantityDefinition.Name} lhs, {quantityDefinition.Name} rhs)
{{
    return new {quantityDefinition.Name}(QuantityOperations.Add(lhs, rhs));
}}

public static {quantityDefinition.Name} operator -({quantityDefinition.Name} lhs, {quantityDefinition.Name} rhs)
{{
    return new {quantityDefinition.Name}(QuantityOperations.Subtract(lhs, rhs));
}}

public static double operator /({quantityDefinition.Name} lhs, {quantityDefinition.Name} rhs)
{{
    return QuantityOperations.Divide(lhs, rhs).Value;
}}

public static bool operator ==({quantityDefinition.Name} lhs, {quantityDefinition.Name} rhs)
{{
    return QuantityHelper.AreEqual(lhs, rhs);
}}

public static bool operator !=({quantityDefinition.Name} lhs, {quantityDefinition.Name} rhs)
{{
    return !QuantityHelper.AreEqual(lhs, rhs);
}}

public static bool operator >=({quantityDefinition.Name} lhs, {quantityDefinition.Name} rhs)
{{
    return QuantityHelper.CompareTo(lhs, rhs) >= 0;
}}

public static bool operator <=({quantityDefinition.Name} lhs, {quantityDefinition.Name} rhs)
{{
    return QuantityHelper.CompareTo(lhs, rhs) <= 0;
}}

public static bool operator >({quantityDefinition.Name} lhs, {quantityDefinition.Name} rhs)
{{
    return QuantityHelper.CompareTo(lhs, rhs) > 0;
}}

public static bool operator <({quantityDefinition.Name} lhs, {quantityDefinition.Name} rhs)
{{
    return QuantityHelper.CompareTo(lhs, rhs) < 0;
}}

public static Interval<{quantityDefinition.Name}> Interval(double min, double max, SelectUnit<{quantityDefinition.UnitSelector}> unitSelector)
{{
    return new Interval<{quantityDefinition.Name}>(min, max, unitSelector(new {quantityDefinition.UnitSelector}()));
}}

public Squared<{quantityDefinition.Name}> Squared()
{{
    return new Squared<{quantityDefinition.Name}>(this);
}}

public Cubed<{quantityDefinition.Name}> Cubed()
{{
    return new Cubed<{quantityDefinition.Name}>(this);
}}
");
        }
        
        private static GeneratorString GetConversionOperations(QuantityDefinition quantityDefinition)
        {
            return new GeneratorString(8, $@"
public double ToDouble(IUnit unit)
{{
    return QuantityOperations.ConvertToUnit(this, unit);
}}

public IQuantity ToQuantity(IUnit unit)
{{
    return this.ToUnit(unit);
}}

public {quantityDefinition.Name} ToUnit(IUnit unit)
{{
    return new {quantityDefinition.Name}(this.ToDouble(unit), unit);
}}

public {quantityDefinition.Name} ToUnit(SelectUnit<{quantityDefinition.UnitSelector}> unitSelector)
{{
    return this.ToUnit(UnitBuilder.BuildUnit(unitSelector(new {quantityDefinition.UnitSelector}())));
}}

public double ToDouble(SelectUnit<{quantityDefinition.UnitSelector}> unitSelector)
{{
    return this.ToDouble(UnitBuilder.BuildUnit(unitSelector(new {quantityDefinition.UnitSelector}())));
}}
");
        }

        private static GeneratorString GetEqualityOperations(QuantityDefinition quantityDefinition)
        {
            return new GeneratorString(8, $@"
public override int GetHashCode()
{{
    return QuantityHelper.GetHashCode(this);
}}

public override bool Equals(object obj)
{{
    return QuantityHelper.AreEqual(this, obj);
}}

public bool Equals(IQuantity quantity)
{{
    return QuantityHelper.AreEqual(this, quantity);
}}

public bool Equals({quantityDefinition.Name} quantity)
{{
    return QuantityHelper.AreEqual(this, quantity);
}}

public int CompareTo(object obj)
{{
    return QuantityHelper.CompareTo<{quantityDefinition.Name}>(this, obj);
}}

public int CompareTo(IQuantity quantity)
{{
    return QuantityHelper.CompareTo(this, quantity);
}}

public int CompareTo({quantityDefinition.Name} quantity)
{{
    return QuantityHelper.CompareTo(this, quantity);
}}
");
        }

        private static GeneratorString GetToStringOperations(QuantityDefinition quantityDefinition)
        {
            return new GeneratorString(8, $@"
public override string ToString()
{{
    return this.ToString(CultureInfo.CurrentCulture);
}}

public string ToString(UnitFormat unitFormat)
{{
    return this.ToString(unitFormat, null, CultureInfo.CurrentCulture);
}}

public string ToString(string format)
{{
    return this.ToString(format, CultureInfo.CurrentCulture);
}}

public string ToString(IFormatProvider formatProvider)
{{
    return this.ToString(null, formatProvider);
}}

public string ToString(UnitFormat unitFormat, string format)
{{
    return this.ToString(unitFormat, format, CultureInfo.CurrentCulture);
}}

public string ToString(UnitFormat unitFormat, IFormatProvider formatProvider)
{{
    return this.ToString(unitFormat, null, formatProvider);
}}

public string ToString(string format, IFormatProvider formatProvider)
{{
    return this.ToString(UnitFormat.Default, format, formatProvider);
}}

public string ToString(UnitFormat unitFormat, string format, IFormatProvider formatProvider)
{{
    return QuantityHelper.ToString(
        this.Unit.FormatValue(this.value, format, formatProvider),
        UnitFormatHelper.GetNotation(this.Unit, unitFormat));
}}
");
        }

        private static string GetNamespace(Project project, string targetNamespace)
        {
            var defaultNamespace = "";
            var xDocument = XDocument.Load(project.FilePath);
            foreach (var propertyGroupElement in xDocument.Root.Elements().Where(x => x.Name.LocalName.Equals("PropertyGroup")))
            {
                var defaultNamespaceElement = propertyGroupElement.Elements().FirstOrDefault(x => x.Name.LocalName.Equals("RootNamespace"));
                if (defaultNamespaceElement != null)
                {
                    defaultNamespace = defaultNamespaceElement.Value;
                }

                if (string.IsNullOrEmpty(defaultNamespace))
                {
                    defaultNamespaceElement = propertyGroupElement.Elements().FirstOrDefault(x => x.Name.LocalName.Equals("DefaultNamespace"));
                    if (defaultNamespaceElement != null)
                    {
                        defaultNamespace = defaultNamespaceElement.Value;
                    }
                }

                if (string.IsNullOrEmpty(targetNamespace))
                {
                    return defaultNamespace;
                }

                return $"{defaultNamespace}.{targetNamespace}";
            }

            throw new NotSupportedException("A namespace is required");
        }
    }
}